/*
 * $OpenXM: $
*/
#include <stdio.h>

#if defined(__MWERKS__)
#define THINK_C
#endif

#if defined(GO32) || defined(__WIN32__)
#define TOWNS
#endif

#if (defined(sun) && !defined(SYSV)) || defined(news5000) || (defined(mips) && defined(ultrix))
#include <alloca.h>
#endif

#if (defined(TOWNS) && !defined(__WIN32__)) || (defined(sun) && defined(SYSV))
#define alloca(x) __builtin_alloca(x)
#endif

#if 0
#include <sys/types.h>
typedef caddr_t pointer;
#endif

#ifndef PARI
/* for THINK C ... */
#define PARI 1
#endif

typedef char * pointer;

#if defined(__WIN32__)
#include <string.h>
#define index(s,c) strchr(s,c)
#define bzero(s,len) memset(s,0,len)
#define bcopy(x,y,len) memcpy(y,x,len)
#endif

/* data structures */

#define O_N 1
#define O_P 2
#define O_R 3
#define O_LIST 4
#define O_VECT 5
#define O_MAT 6
#define O_STR 7
#define O_COMP 8
#define O_DP 9

#define N_Q 0
#define N_R 1
#define N_A 2
#define N_B 3
#define N_C 4
#define N_M 5

#define ORD_REVGRADLEX 0
#define ORD_GRADLEX 1
#define ORD_LEX 2

struct oN {
	int p;
	int b[1];
};

typedef struct oN *N;

struct oV {
	char *name;
	pointer attr;
	pointer priv;
};

typedef struct oV *V;

struct oQ {
	short id;
	char nid;
	char sgn;
	N nm;
	N dn;
};

typedef struct oQ *Q;

struct oReal {
	short id;
	char nid;
	char pad;
	double body;
};

typedef struct oReal *Real;

struct oAlg {
	short id;
	char nid;
	char pad;
	struct oObj *body;
};

typedef struct oAlg *Alg;

struct oBF {
	short id;
	char nid;
	char pad;
	long body[1];
};

typedef struct oBF *BF;

struct oC {
	short id;
	char nid;
	char pad;
	struct oNum *r,*i;
};

typedef struct oC *C;

struct oNum {
	short id;
	char nid;
	char pad;
};

typedef struct oNum *Num;

struct oMQ {
	short id;
	char nid;
	char pad;
	int cont;
};

typedef struct oMQ *MQ;

struct oP {
	short id;
	short pad;
	V v;
	struct oDCP *dc;
};

typedef struct oP *P;

struct oR {
	short id;
	short reduced;
	P nm;
	P dn;
};

typedef struct oR *R;

struct oVECT {
	short id;
	short pad;
	int len;
	pointer *body;
};

typedef struct oVECT *VECT;

struct oMAT {
	short id;
	short pad;
	int row,col;
	pointer **body;
};

typedef struct oMAT *MAT;

struct oLIST {
	short id;
	short pad;
	struct oNODE *body;
};

typedef struct oLIST *LIST;

struct oSTRING {
	short id;
	short pad;
	char *body;
};

typedef struct oSTRING *STRING;

struct oCOMP {
	short id;
	short type;
	struct oObj *member[1];
};

typedef struct oCOMP *COMP;

struct oDP {
	short id;
	short nv;
	int sugar;
	struct oMP *body;
};

typedef struct oDP *DP;

struct oObj {
	short id;
	short pad;
};

typedef struct oObj *Obj;

struct oDCP {
	Q d;
	P c;
	struct oDCP *next;	
};

typedef struct oDCP *DCP;

struct oMP {
	struct oDL *dl;
	P c;
	struct oMP *next;
};

typedef struct oMP *MP;

struct oDL {
	int td;
	int d[1];
};

typedef struct oDL *DL;

struct oVL {
	V v;
	struct oVL *next;
};

typedef struct oVL *VL;

struct oNODE {
	pointer body;
	struct oNODE *next;
};

typedef struct oNODE *NODE;

struct oUM {
	int d;
	int c[1];
};

typedef struct oUM *UM;

struct oLUM {
	int d;
	int *c[1];
};

typedef struct oLUM *LUM;

struct oML {
	int n;
	int mod;
	int bound;
	pointer c[1];
};

typedef struct oML *ML;

struct oUB {
	int d;
	N c[1];
};

typedef struct oUB *UB;

struct oVN {
	V v;
	int n;
};

typedef struct oVN *VN;

struct oDUM {
	int n;
	UM f;
};

struct order_pair {
	int order, length;
};

struct order_spec {
	int id;
	Obj obj;
	int nv;
	union {
		int simple;
		struct {
			int length;
			struct order_pair *order_pair;
		} block;
		struct {
			int row;
			int **matrix;
		} matrix;
	} ord;
};

/* structure for cputime */

struct oEGT {
	double exectime,gctime;
};

/* include interval.h */
#include "interval.h"

/* constant */
#define INDEX 100

/* general macros */
#define MAX(a,b) ((a) > (b) ? (a) : (b) )
#define MIN(a,b) ((a) > (b) ? (b) : (a) )
#ifdef ABS
#undef ABS
#endif
#define ABS(a) ((a)>0?(a):-(a))
#define ID(p) ((p)->id)
#define OID(p) (((Obj)(p))->id)
#define NID(p) (((Num)(p))->nid)
#define BDY(p) ((p)->body)
#define VR(p) ((p)->v)
#define NAME(p) ((p)->name)
#define NEXT(p) ((p)->next)
#define NM(q) ((q)->nm)
#define DN(q) ((q)->dn)
#define SGN(q) ((q)->sgn)
#define DC(p) ((p)->dc)
#define COEF(p) ((p)->c)
#define DEG(p) ((p)->d)
#define PL(n) ((n)->p)
#define BD(n) ((n)->b)
#define CONT(a) ((a)->cont)
#define UDEG(f) BD(NM(DEG(DC(f))))[0]
#define UCOEF(f) (COEF(DC(f)))
#define LC(f) (NUM(f)?(f):COEF(DC(f)))

/* memory allocators (W_... : uses alloca) */

#if defined(__GNUC__) || defined(vax) || defined(apollo) || defined(alloca)
#define ALLOCA(d) alloca(d)
#else
#define ALLOCA(d) GC_malloc(d)
#endif

#define MALLOC(d) GC_malloc(d)
#define MALLOC_ATOMIC(d) GC_malloc_atomic(d)
#define CALLOC(d,e) GC_malloc((d)*(e))

#define TRUESIZE(type,n,atype) (sizeof(struct type)+MAX((n),0)*sizeof(atype))
#define NALLOC(d) ((N)MALLOC_ATOMIC(TRUESIZE(oN,(d)-1,int)))
#define UMALLOC(d) ((UM)MALLOC(TRUESIZE(oUM,d,int)))
#define C_UMALLOC(d) ((UM)MALLOC(TRUESIZE(oUM,d,int)))
#define MLALLOC(d) ((ML)MALLOC(TRUESIZE(oML,d,pointer)))

#define W_ALLOC(d) ((int *)ALLOCA(((d)+1)*sizeof(int)))
#define W_CALLOC(n,type,p) \
((p)=(type *)ALLOCA(((n)+1)*sizeof(type)),\
bzero((char *)(p),(int)(((n)+1)*sizeof(type))))
#define W_UMALLOC(d) ((UM)ALLOCA(TRUESIZE(oUM,d,int)))
#define W_MLALLOC(d) ((ML)ALLOCA(TRUESIZE(oML,d,pointer)))
#define W_LUMALLOC(n,bound,p)\
{\
	LUM ___q___;\
	int ___i___,**___c___;\
	(___q___) = (LUM)ALLOCA(TRUESIZE(oLUM,(n),int *));\
	DEG(___q___) = n;\
	for ( ___i___ = 0, ___c___ = (int **)COEF(___q___); ___i___ <= n; ___i___++ ) {\
		___c___[___i___] = (int *)ALLOCA(((bound)+1)*sizeof(int));\
		bzero((char *)___c___[___i___],((bound)+1)*sizeof(int));\
	}\
	(p) = ___q___;\
}

/* cell allocators */
#define NEWQ(q) ((q)=(Q)MALLOC(sizeof(struct oQ)),OID(q)=O_N,NID(q)=N_Q)
#define NEWMQ(q) ((q)=(MQ)MALLOC_ATOMIC(sizeof(struct oMQ)),OID(q)=O_N,NID(q)=N_M)
#define NEWP(p) ((p)=(P)MALLOC(sizeof(struct oP)),OID(p)=O_P)
#define NEWR(r) ((r)=(R)MALLOC(sizeof(struct oR)),OID(r)=O_R,(r)->reduced=0)
#define NEWLIST(l) ((l)=(LIST)MALLOC(sizeof(struct oLIST)),OID(l)=O_LIST)
#define NEWVECT(l) ((l)=(VECT)MALLOC(sizeof(struct oVECT)),OID(l)=O_VECT)
#define NEWSTR(l) ((l)=(STRING)MALLOC(sizeof(struct oSTRING)),OID(l)=O_STR)
#define NEWCOMP(c,n) ((c)=(COMP)MALLOC(sizeof(struct oCOMP)+((n)-1)*sizeof(Obj)),OID(c)=O_COMP)
#define NEWDP(d) ((d)=(DP)MALLOC(sizeof(struct oDP)),OID(d)=O_DP)

#define NEWNODE(a) ((a)=(NODE)MALLOC(sizeof(struct oNODE)))
#define NEWDC(dc) ((dc)=(DCP)MALLOC(sizeof(struct oDCP)))
#define NEWV(v) ((v)=(V)MALLOC(sizeof(struct oV)))
#define NEWVL(vl) ((vl)=(VL)MALLOC(sizeof(struct oVL)))
#define NEWMP(m) ((m)=(MP)MALLOC(sizeof(struct oMP)))

#define NEWMAT(l) ((l)=(MAT)MALLOC(sizeof(struct oMAT)),OID(l)=O_MAT)
#define NEWReal(q) ((q)=(Real)MALLOC_ATOMIC(sizeof(struct oReal)),OID(q)=O_N,NID(q)=N_R)
#define NEWAlg(r) ((r)=(Alg)MALLOC(sizeof(struct oAlg)),OID(r)=O_N,NID(r)=N_A)
#define NEWBF(q,l) ((q)=(BF)MALLOC_ATOMIC(TRUESIZE(oBF,(l)-1,long)),OID(q)=O_N,NID(q)=N_B)
#define NEWC(r) ((r)=(C)MALLOC(sizeof(struct oC)),OID(r)=O_N,NID(r)=N_C)
#define NEWDL(d,n) \
((d)=(DL)MALLOC_ATOMIC(TRUESIZE(oDL,(n)-1,int)),bzero((char *)(d),TRUESIZE(oDL,(n)-1,int)))

#define MKP(v,dc,p) \
(!DEG(dc)?((p)=COEF(dc)):(NEWP(p),VR(p)=(v),DC(p)=(dc),(p)))
#define MKV(v,p) \
(NEWP(p),VR(p)=(v),NEWDC(DC(p)),\
DEG(DC(p))=ONE,COEF(DC(p))=(P)ONE,NEXT(DC(p))=0)
#define MKRAT(n,d,r,p) \
(NEWR(p),NM(p)=(n),DN(p)=(d),(p)->reduced=(r))
#define MKMV(v,p) \
(NEWP(p),VR(p)=(v),NEWDC(DC(p)),\
DEG(DC(p))=ONE,COEF(DC(p))=(P)ONEM,NEXT(DC(p))=0)
#define MKNODE(a,b,c) \
(NEWNODE(a),(a)->body=(pointer)b,NEXT(a)=(NODE)(c))
#define MKLIST(a,b) (NEWLIST(a),(a)->body=(NODE)(b))
#define MKVECT(m,l) \
(NEWVECT(m),(m)->len=(l),(m)->body=(pointer *)CALLOC((l),sizeof(pointer)))
#define MKMAT(m,r,c) \
(NEWMAT(m),(m)->row=(r),(m)->col=(c),(m)->body=(pointer **)almat_pointer((r),(c)))
#define MKSTR(a,b) (NEWSTR(a),(a)->body=(char *)(b))
#define MKDP(n,m,d) (NEWDP(d),(d)->nv=(n),BDY(d)=(m))

#define NEXTDC(r,c) \
if(!(r)){NEWDC(r);(c)=(r);}else{NEWDC(NEXT(c));(c)=NEXT(c);}
#define NEXTNODE(r,c) \
if(!(r)){NEWNODE(r);(c)=(r);}else{NEWNODE(NEXT(c));(c)=NEXT(c);}
#define NEXTMP(r,c) \
if(!(r)){NEWMP(r);(c)=(r);}else{NEWMP(NEXT(c));(c)=NEXT(c);}

/* convertors */
#define NTOQ(n,s,q) \
(!(n)?((q)=0):(NEWQ(q),SGN(q)=(s),NM(q)=(n),DN(q)=0,(q)))
#define NDTOQ(n,d,s,q) \
(!(d)?NTOQ(n,s,q):(NEWQ(q),SGN(q)=(s),NM(q)=(n),DN(q)=(d),(q)))
#define DUPQ(p,q) \
(NEWQ(q),SGN(q)=SGN(p),NM(q)=NM(p),DN(q)=DN(p))
#define STOQ(n,q) \
((!(n))?((q)=(Q)NULL):(NEWQ(q),\
SGN(q)=((n)>0?1:-1),NM(q)=NALLOC(1),\
PL(NM(q))=1,BD(NM(q))[0]=ABS(n),DN(q)=0,(q)))
#define STOMQ(a,b) \
((a)?(NEWMQ(b),CONT(b)=(a),(b)):((b)=0))
#define QTOS(q) (!(q)?0:SGN(q)*BD(NM(q))[0])
#define STON(i,n)\
(i?((n)=NALLOC(1),PL(n)=1,BD(n)[0]=ABS(i),(n)):((n)=(N)0))
#define PTOR(a,b) \
(!(a)?((b)=0):(NEWR(b),NM(b)=(a),DN(b)=(P)ONE,(b)->reduced=1,(b)))
#define RTOS(a) (!(a)?0:QTOS((Q)NM((R)a)))
#define MKReal(a,b) (!(a)?((b)=0):(NEWReal(b),BDY(b)=(a),(b)))
#define MKAlg(b,r) \
(!(b)?((r)=0):NUM(b)?((r)=(Alg)(b)):(NEWAlg(r),BDY(r)=(Obj)(b),(r)))

#define ToReal(a) (!(a)?(double)0.0:REAL(a)?BDY((Real)a):RATN(a)?RatnToReal((Q)a):0)

/* predicates */
#define NUM(p) (OID(p)==O_N)
#define RAT(p) (OID(p)==O_R)
#define INT(q) (!DN((Q)q))
#define RATN(a) (NID(a)==N_Q)
#define REAL(a) (NID(a)==N_R)
#define UNIQ(q) ((q)&&NUM(q)&&(SGN((Q)q)==1)&&UNIN(NM((Q)q))&&(!DN((Q)q)))
#define UNIMQ(q) ((q)&&NUM(q)&&(CONT((MQ)q)==1))
#define MUNIQ(q) ((q)&&NUM(q)&&(SGN((Q)q)==-1)&&UNIN(NM((Q)q))&&(!DN((Q)q)))
#define MUNIMQ(q) ((q)&&NUM(q)&&(CONT((MQ)q)==-1))
#define UNIN(n) ((n)&&(PL(n)==1)&&(BD(n)[0]==1))
#define EVENN(n) ((!(n))||(!(BD(n)[0]%2)))


/* externals */
#if 0
double NatToReal();
double RatnToReal();
#endif

extern struct oR oUNIR;
extern struct oQ oUNIQ;
extern struct oMQ oUNIMQ;
extern struct oN oUNIN;
extern struct oV oVAR[];
extern struct oV oPVAR[];
extern struct oVL oVLIST[];
extern struct oVL oPVLIST[];
extern VL CO,ALG;
extern VL PVL;
extern R ONER;
extern Q ONE;
extern MQ ONEM;
extern N ONEN;
extern FILE *asir_out;
#if defined(__GNUC__) || defined(THINK_C)
extern const int sprime[];
extern const int lprime[];
#else
extern int sprime[];
extern int lprime[];
#endif

extern void (*addnumt[])();
extern void (*subnumt[])();
extern void (*mulnumt[])();
extern void (*divnumt[])();
extern void (*pwrnumt[])();
extern int (*cmpnumt[])();
extern void (*chsgnnumt[])();

#if defined(THINK_C) || defined(__WIN32__)
LUM LUMALLOC(int, int);
Obj ToAlg(Num);
UM *berlemain(register int, UM, UM *);
char *GC_malloc(int);
char *GC_malloc_atomic(int);
char *GC_realloc(char *,int);
double NatToReal(N,int *);
double RatnToReal(Q);
double pwrreal0(double,int);
int **almat(int,int);
pointer **almat_pointer(int,int);
int berlecnt(register int,UM);
int berlecntmain(register int,int,int,register int **);
int cmpalg(Num,Num);
int cmpbf(Num,Num);
int cmpcplx(Num,Num);
int cmpn(N,N);
int cmpq(Q,Q);
int cmpreal(Real,Real);
int cmpmi(MQ,MQ);
int compmat(VL,MAT,MAT);
int compnum(VL,Num,Num);
int compp(VL,P,P);
int compr(VL,Obj,Obj);
int compstr(VL,STRING,STRING);
int compvect(VL,VECT,VECT);
int ctest(P,ML,int,int *);
int cycchk(P);
int dbound(V,P);
int dcomp(P,P);
int deg(V,P);
int degtest(int,int *,ML,int);
int divcheck(VL,P *,int,P,P);
int divin(N,register int,N *);
int divtdcpz(VL,P,P,P *);
int divtpz(VL,P,P,P *);
int divum(register int,UM,UM,UM);
int dm(int,int,int *);
int dmb(int,int,int,int *);
int dma(int,int,int,int *);
int dmab(int,int,int,int,int *);
int dmar(int,int,int,int);
int dtestmain(P,Q,ML,int,int *,P *,P *);
int geldb(VL,P);
int getchomdeg(V,P);
int getdeg(V,P);
int getlchomdeg(V,P,int *);
int homdeg(P);
int invm(int,register int);
int iscycm(P);
int iscycp(P);
int lengthp(P);
int mig(int,int,P);
int mignotte(int,P);
int minimain(register int,int,int,register int **);
int ncombi(int,int,int,int *);
int nextbin(VN,int);
int nmonop(P);
int pcoef(VL,VL,P,P *);
int pcoef0(VL,VL,P,P *);
int pwrm(register int,register int,int);
int rem(N,register int);
int sqfrchk(P);
int subn(N,N,N *);
int ucmpp(P,P);
int valideval(VL,DCP,VN);
int zerovpchk(VL,P,VN);
void addalg(Num,Num,Num *);
void addbf(Num,Num,Num *);
void addcplx(Num,Num,Num *);
void addm2p(VL,Q,Q,P,P,P *);
void addm2q(Q,Q,Q,Q,Q *);
void addmat(VL,MAT,MAT,MAT *);
void addmp(VL,int,P,P,P *);
void addmpq(int,P,P,P *);
void addmptoc(VL,int,P,P,P *);
void addmq(int,MQ,MQ,MQ *);
void addn(N,N,N *);
void addnum(VL,Num,Num,Num *);
void addp(VL,P,P,P *);
void addpadic(register int,int,register int *,register int *);
void addpq(P,P,P *);
void addptoc(VL,P,P,P *);
void addq(Q,Q,Q *);
void addr(VL,Obj,Obj,Obj *);
void addreal(Num,Num,Real *);
void addmi(MQ,MQ,MQ *);
void addstr(VL,STRING,STRING,STRING *);
void addum(int,UM,UM,UM);
void addvect(VL,VECT,VECT,VECT *);
void adjc(VL,P,P,P,Q,P *,P *);
void afctr(VL,P,P,DCP *);
void afctrmain(VL,P,P,int,DCP *);
void affine(VL,P,VN,P *);
void affinemain(VL,P,V,int,P *,P *);
void berle(int,int,P,ML *);
void bnton(register int,N,N *);
void cbound(VL,P,Q *);
void chnrem(int,V,P,Q,UM,P *,Q *);
void chnremp(VL,int,P,Q,P,P *);
void chsgnalg(Num,Num *);
void chsgnbf(Num a,Num *);
void chsgncplx(Num,Num *);
void chsgnmat(MAT,MAT *);
void chsgnmp(int,P,P *);
void chsgnnum(Num,Num *);
void chsgnp(P,P *);
void chsgnq(Q,Q *);
void chsgnr(Obj,Obj *);
void chsgnreal(Num,Num *);
void chsgnmi(MQ,MQ *);
void chsgnvect(VECT,VECT *);
void clctv(VL,P,VL *);
void clctvr(VL,Obj,VL *);
void cm2p(Q,Q,P,P *);
void cmax(P,Q *);
void cmp(Q,P,P *);
void coefp(P,int,P *);
void cpylum(int,LUM,LUM);
void cpyum(UM,UM);
void csump(VL,P,Q *);
void cycm(V,register int,DCP *);
void cycp(V,register int,DCP *);
void degp(V,P,Q *);
void degum(UM,int);
void detmp(VL,int,P **,int,P *);
void detp(VL,P **,int,P *);
void diffp(VL,P,V,P *);
void diffum(register int,UM,UM);
void divalg(Num,Num,Num *);
void divbf(Num,Num,Num *);
void divcp(P,Q,P *);
void divcplx(Num,Num,Num *);
void divmat(VL,Obj,Obj,Obj *);
void divmq(int,MQ,MQ,MQ *);
void divn(N,N,N *,N *);
void divnmain(int,int,register int *,register int *,register int *);
void divnum(VL,Num,Num,Num *);
void divq(Q,Q,Q *);
void divr(VL,Obj,Obj,Obj *);
void divreal(Num,Num,Real *);
void divmi(MQ,MQ,MQ *);
void divsdcmp(VL,int,P,P,P *);
void divsdcp(VL,P,P,P *);
void divsmp(VL,int,P,P,P *);
void divsn(N,N,N *);
void divsp(VL,P,P,P *);
void divsrdcmp(VL,int,P,P,P *,P *);
void divsrdcp(VL,P,P,P *,P *);
void divsrmp(VL,int,P,P,P *,P *);
void divsrp(VL,P,P,P *,P *);
void divvect(VL,Obj,Obj,Obj *);
void dtest(P,ML,int,DCP *);
void dtestroot(int,int,P,LUM,struct oDUM *,DCP *);
void dtestroot1(int,int,P,LUM,P *);
void dtestsq(int,int,P,LUM,P *);
void dtestsql(P,ML,struct oDUM *,DCP *);
void estimatelc(VL,Q,DCP,VN,P *);
void eucum(register int,UM,UM,UM,UM);
void exthp(VL,P,int,P *);
void exthpc(VL,V,P,int,P *);
void ezgcd1p(VL,P,P,P *);
void ezgcdhensel(P,int,UM,UM,ML *);
void ezgcdnp(VL,P,P *,int,P *);
void ezgcdnpp(VL,DCP,P *,int,P *);
void ezgcdnpz(VL,P *,int,P *);
void ezgcdp(VL,P,P,P *);
void ezgcdpp(VL,DCP,P,P *);
void ezgcdpz(VL,P,P,P *);
void factorial(int,Q *);
void fctrp(VL,P,DCP *);
void fctrwithmvp(VL,P,V,DCP *);
void gcda(VL,P,P,P,P *);
void gcdcp(VL,P,P *);
void gcdgen(P,ML,ML *);
void gcdmonomial(VL,DCP *,int,P *);
void gcdn(N,N,N *);
void gcdprsp(VL,P,P,P *);
void gcdum(register int,UM,UM,UM);
void getmindeg(V,P,Q *);
void henmain(LUM,ML,ML,ML *);
void henmv(VL,VN,P,P,P,P,P,P,P,P,P,Q,int,P *,P *);
void henmvmain(VL,VN,P,P,P,P,P,P,P,Q,Q,int,P *,P *);
void henprep(P,ML,ML,ML *,ML *);
void hensel(int,int,P,ML *);
void henzq(P,P,UM,P,UM,int,int,P *,P *,P *,P *,Q *);
void henzq1(P,P,Q,P *,P *,Q *);
void hsq(int,int,P,int *,DCP *);
void intersectv(VL,VL,VL *);
void invl(Q,Q,Q *);
void invmq(int,MQ,MQ *);
void invq(Q,Q *);
void lgp(P,N *,N *);
void lumtop(V,int,int,LUM,P *);
void markv(VN,int,P);
void maxdegp(VL,P,VL *,P *);
void mergev(VL,VL,VL,VL *);
void mfctr(VL,P,DCP *);
void mfctrhen2(VL,VN,P,P,P,P,P,P,P *);
void mfctrmain(VL,P,DCP *);
void mfctrwithmv(VL,P,V,DCP *);
void min_common_vars_in_coefp(VL,P,VL *,P *);
void minchdegp(VL,P,VL *,P *);
void mindegp(VL,P,VL *,P *);
void mini(register int,UM,UM);
void minlcdegp(VL,P,VL *,P *);
void mkbc(int,Q *);
void mkbcm(int,int,MQ *);
void mkssum(V,int,int,int,P *);
void monomialfctr(VL,P,P *,DCP *);
void mptop(P,P *);
void mptoum(P,UM);
void msqfr(VL,P,DCP *);
void msqfrmain(VL,P,DCP *);
void msqfrmainmain(VL,P,VN,P,DCP,DCP *,P *);
void mulalg(Num,Num,Num *);
void mulbf(Num,Num,Num *);
void mulcplx(Num,Num,Num *);
void mulin(N,register int,register int *);
void mullum(int,int,LUM,LUM,LUM);
void mullumarray(P,ML,int,int *,P *);
void mulm2p(VL,Q,Q,P,P,P *);
void mulm2q(Q,Q,Q,Q,Q *);
void mulmat(VL,Obj,Obj,Obj *);
void mulmatmat(VL,MAT,MAT,MAT *);
void mulmatvect(VL,MAT,VECT,VECT *);
void mulmp(VL,int,P,P,P *);
void mulmpc(VL,int,P,P,P *);
void mulmpq(int,P,P,P *);
void mulmq(int,MQ,MQ,MQ *);
void muln(N,N,N *);
void mulnum(VL,Num,Num,Num *);
void mulp(VL,P,P,P *);
void mulpadic(register int,int,int *,int *,int *);
void mulpc(VL,P,P,P *);
void mulpq(P,P,P *);
void mulq(Q,Q,Q *);
void mulr(VL,Obj,Obj,Obj *);
void mulreal(Num,Num,Real *);
void mulmi(MQ,MQ,MQ *);
void mulrmat(VL,Obj,MAT,MAT *);
void mulrvect(VL,Obj,VECT,VECT *);
void mulsgn(VN,VN,int,VN);
void mulsum(register int,UM,register int,UM);
void mulum(register int,UM,UM,UM);
void mulvect(VL,Obj,Obj,Obj *);
void mulvectmat(VL,VECT,MAT,VECT *);
void next(VN);
void nezgcdnp_sqfr_primitive(VL,P,P *,int,P *);
void nezgcdnpp(VL,DCP,P *,int,P *);
void nezgcdnpz(VL,P *,int,P *);
void nezgcdnpzmain(VL,P *,int,P *);
void nglob_init(void);
void norm(P,Q *);
void norm1(P,P *);
void norm1c(P,Q *);
void normalizemp(int,P);
void nthrootchk(P,struct oDUM *,ML,DCP *);
void nthrootn(N,int,N *);
void ntobn(register int,N,N *);
void nuezgcdnpzmain(VL,P *,int,P *);
void padictoq(int,int,int *,Q *);
void pari_init(void);
void pcp(VL,P,P *,P *);
void pderivr(VL,Obj,V,Obj *);
void pdiva(VL,P,P,P,P *);
void pinva(P,P,P *);
void plisttop(P *,V,int,P *);
void pmonic(VL,P,P,P *);
void pqra(VL,P,P,P,P *,P *);
void premmp(VL,int,P,P,P *);
void premp(VL,P,P,P *);
void ptolum(int,int,P,LUM);
void ptomp(int,P,P *);
void ptoum(int,P,UM);
void ptozp(P,int,Q *,P *);
void ptozp0(P,P *);
void pwralg(Num,Num,Num *);
void pwrbf(Num,Num,Num *);
void pwrcplx(Num,Num,Num *);
void pwrcplx0(Num,int,Num *);
void pwrlum(int,int,LUM,int,LUM);
void pwrmat(VL,MAT,Obj,MAT *);
void pwrmatmain(VL,MAT,int,MAT *);
void pwrmp(VL,int,P,Q,P *);
void pwrmq(int,MQ,Q,MQ *);
void pwrn(N,int,N *);
void pwrnum(VL,Num,Num,Num *);
void pwrp(VL,P,Q,P *);
void pwrq(Q,Q,Q *);
void pwrr(VL,Obj,Obj,Obj *);
void pwrreal(Num,Num,Real *);
void pwrmi(MQ,Q,MQ *);
void pwrum(int,UM,int,UM);
void reallocarray(char **,int *,int *,int);
void reductr(VL,Obj,Obj *);
void reimtocplx(Num,Num,Num *);
void rem2q(Q,Q,Q,Q *);
void rema(VL,P,P,P,P *);
void remq(Q,Q,Q *);
void remsdcp(VL,P,P,P *);
void reordermp(VL,int,VL,P,P *);
void reorderp(VL,VL,P,P *);
void reordvar(VL,V,VL *);
void res_ch_det(VL,V,P,P,P *);
void res_detmp(VL,int,V,P,P,P *);
void restore(VL,P,VN,P *);
void resultmp(VL,int,V,P,P,P *);
void resultp(VL,V,P,P,P *);
void setlum(int,int,LUM);
void sort_by_deg(int,P *,P *);
void sort_by_deg_rev(int,P *,P *);
void sortfs(DCP *);
void sortfsrev(DCP *);
void sortplist(P *,int);
void sortplistbyhomdeg(P *,int);
void sprs(VL,V,P,P,P *);
void sqa(VL,P,P,DCP *);
void sqad(int,int);
void sqfrp(VL,P,DCP *);
void sqfrum(int,int,P,int *,struct oDUM **,ML *);
void sqfrummain(int,UM,UM,struct oDUM **);
void sqrtn(N,N *);
void srch2(VL,V,P,P,P *);
void srchmp(VL,int,V,P,P,P *);
void srchump(int,P,P,P *);
void srcr(VL,V,P,P,P *);
void strtobf(char *,BF *);
void subalg(Num,Num,Num *);
void subbf(Num,Num,Num *);
void subcplx(Num,Num,Num *);
void subm2p(VL,Q,Q,P,P,P *);
void subm2q(Q,Q,Q,Q,Q *);
void submat(VL,MAT,MAT,MAT *);
void submp(VL,int,P,P,P *);
void submq(int,MQ,MQ,MQ *);
void subnum(VL,Num,Num,Num *);
void subp(VL,P,P,P *);
void subq(Q,Q,Q *);
void subr(VL,Obj,Obj,Obj *);
void subreal(Num,Num,Real *);
void submi(MQ,MQ,MQ *);
void substmp(VL,int,P,V,P,P *);
void substp(VL,P,V,P,P *);
void substvp(VL,P,VN,P *);
void subum(int,UM,UM,UM);
void subvect(VL,VECT,VECT,VECT *);
void toreim(Num,Num *,Num *);
void ucsump(P,Q *);
void udivpwm(Q,P,P,P *,P *);
void udivpz(P,P,P *,P *);
void udivpzwm(Q,P,P,P *,P *);
void uexgcdnp(VL,P,P *,int,VN,Q,P *,P *,P *,P *,Q *);
void uezgcd1p(P,P,P *);
void uezgcdpp(DCP,P,P *);
void uezgcdpz(VL,P,P,P *);
void ufctr(P,int,DCP *);
void ufctrmain(P,int,DCP *);
void umtomp(V,UM,P *);
void umtop(V,UM,P *);
void usqp(P,DCP *);
void vntovl(VN,int,VL *);
#if !defined(__WIN32__)
void bzero(char *,int);
void bcopy(char *,char *,int);
char *index(char *,char);
#endif

void initd(struct order_spec *);
void ptod(VL,VL,P,DP *);
void dtop(VL,VL,DP,P *);
int sugard(MP);
void addd(VL,DP,DP,DP *);
void subd(VL,DP,DP,DP *);
void muld(VL,DP,DP,DP *);
void chsgnd(DP,DP *);
void muldm(VL,DP,MP,DP *);
void adddl(int,DL,DL,DL *);
int compd(VL,DP,DP);
int cmpdl_lex(int,DL,DL);
int cmpdl_gradlex(int,DL,DL);
int cmpdl_revgradlex(int,DL,DL);
#else
LUM LUMALLOC();
Obj ToAlg();
UM *berlemain();
char *GC_malloc();
char *GC_malloc_atomic();
double NatToReal();
double RatnToReal();
double pwrreal0();
int **almat();
pointer **almat_pointer();
int berlecnt();
int berlecntmain();
int cmpalg();
int cmpbf();
int cmpcplx();
int cmpn();
int cmpq();
int cmpreal();
int cmpmi();
int compmat();
int compnum();
int compp();
int compr();
int compstr();
int compvect();
int ctest();
int cycchk();
int dbound();
int dcomp();
int deg();
int degtest();
int divcheck();
int divin();
int divtdcpz();
int divtpz();
int divum();
int dm();
int dmb();
int dma();
int dmab();
int dmar();
int dtestmain();
int geldb();
int getchomdeg();
int getdeg();
int getlchomdeg();
int homdeg();
int invm();
int iscycm();
int iscycp();
int lengthp();
int mig();
int mignotte();
int minimain();
int ncombi();
int nextbin();
int nmonop();
int pcoef();
int pcoef0();
int pwrm();
int rem();
int sqfrchk();
int subn();
int ucmpp();
int valideval();
int zerovpchk();
void addalg();
void addbf();
void addcplx();
void addm2p();
void addm2q();
void addmat();
void addmp();
void addmpq();
void addmptoc();
void addmq();
void addn();
void addnum();
void addp();
void addpadic();
void addpq();
void addptoc();
void addq();
void addr();
void addreal();
void addmi();
void addstr();
void addum();
void addvect();
void adjc();
void afctr();
void afctrmain();
void affine();
void affinemain();
void berle();
void bnton();
void cbound();
void chnrem();
void chnremp();
void chsgnalg();
void chsgnbf();
void chsgncplx();
void chsgnmat();
void chsgnmp();
void chsgnnum();
void chsgnp();
void chsgnq();
void chsgnr();
void chsgnreal();
void chsgnmi();
void chsgnvect();
void clctv();
void clctvr();
void cm2p();
void cmax();
void cmp();
void coefp();
void cpylum();
void cpyum();
void csump();
void cycm();
void cycp();
void degp();
void degum();
void detmp();
void detp();
void diffp();
void diffum();
void divalg();
void divbf();
void divcp();
void divcplx();
void divmat();
void divmq();
void divn();
void divnmain();
void divnum();
void divq();
void divr();
void divreal();
void divmi();
void divsdcmp();
void divsdcp();
void divsmp();
void divsn();
void divsp();
void divsrdcmp();
void divsrdcp();
void divsrmp();
void divsrp();
void divvect();
void dtest();
void dtestroot();
void dtestroot1();
void dtestsq();
void dtestsql();
void estimatelc();
void eucum();
void exthp();
void exthpc();
void ezgcd1p();
void ezgcdhensel();
void ezgcdnp();
void ezgcdnpp();
void ezgcdnpz();
void ezgcdp();
void ezgcdpp();
void ezgcdpz();
void factorial();
void fctrp();
void fctrwithmvp();
void gcda();
void gcdcp();
void gcdgen();
void gcdmonomial();
void gcdn();
void gcdprsp();
void gcdum();
void getmindeg();
void henmain();
void henmv();
void henmvmain();
void henprep();
void hensel();
void henzq();
void henzq1();
void hsq();
void intersectv();
void invl();
void invmq();
void invq();
void lgp();
void lumtop();
void markv();
void maxdegp();
void mergev();
void mfctr();
void mfctrhen2();
void mfctrmain();
void mfctrwithmv();
void min_common_vars_in_coefp();
void minchdegp();
void mindegp();
void mini();
void minlcdegp();
void mkbc();
void mkbcm();
void mkssum();
void monomialfctr();
void mptop();
void mptoum();
void msqfr();
void msqfrmain();
void msqfrmainmain();
void mulalg();
void mulbf();
void mulcplx();
void mulin();
void mullum();
void mullumarray();
void mulm2p();
void mulm2q();
void mulmat();
void mulmatmat();
void mulmatvect();
void mulmp();
void mulmpc();
void mulmpq();
void mulmq();
void muln();
void mulnum();
void mulp();
void mulpadic();
void mulpc();
void mulpq();
void mulq();
void mulr();
void mulreal();
void mulmi();
void mulrmat();
void mulrvect();
void mulsgn();
void mulsum();
void mulum();
void mulvect();
void mulvectmat();
void next();
void nezgcdnp_sqfr_primitive();
void nezgcdnpp();
void nezgcdnpz();
void nezgcdnpzmain();
void nglob_init();
void norm();
void norm1();
void norm1c();
void normalizemp();
void nthrootchk();
void nthrootn();
void ntobn();
void nuezgcdnpzmain();
void padictoq();
void pari_init();
void pcp();
void pderivr();
void pdiva();
void pinva();
void plisttop();
void pmonic();
void pqra();
void premmp();
void premp();
void ptolum();
void ptomp();
void ptoum();
void ptozp();
void ptozp0();
void pwralg();
void pwrbf();
void pwrcplx();
void pwrcplx0();
void pwrlum();
void pwrmat();
void pwrmatmain();
void pwrmp();
void pwrmq();
void pwrn();
void pwrnum();
void pwrp();
void pwrq();
void pwrr();
void pwrreal();
void pwrmi();
void pwrum();
void reallocarray();
void reductr();
void reimtocplx();
void rem2q();
void rema();
void remq();
void remsdcp();
void reordermp();
void reorderp();
void reordvar();
void res_ch_det();
void res_detmp();
void restore();
void resultmp();
void resultp();
void setlum();
void sort_by_deg();
void sort_by_deg_rev();
void sortfs();
void sortfsrev();
void sortplist();
void sortplistbyhomdeg();
void sprs();
void sqa();
void sqad();
void sqfrp();
void sqfrum();
void sqfrummain();
void sqrtn();
void srch2();
void srchmp();
void srchump();
void srcr();
void strtobf();
void subalg();
void subbf();
void subcplx();
void subm2p();
void subm2q();
void submat();
void submp();
void submq();
void subnum();
void subp();
void subq();
void subr();
void subreal();
void submi();
void substmp();
void substp();
void substvp();
void subum();
void subvect();
void toreim();
void ucsump();
void udivpwm();
void udivpz();
void udivpzwm();
void uexgcdnp();
void uezgcd1p();
void uezgcdpp();
void uezgcdpz();
void ufctr();
void ufctrmain();
void umtomp();
void umtop();
void usqp();
void vntovl();
void bzero();
void bcopy();
char *index();

void initd();
void ptod();
void dtop();
int sugard();
void addd();
void subd();
void muld();
void chsgnd();
void muldm();
void adddl();
int compd();
int cmpdl_lex();
int cmpdl_gradlex();
int cmpdl_revgradlex();
#endif
