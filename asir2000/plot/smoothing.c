/* $OpenXM: OpenXM_contrib2/asir2000/plot/smoothing.c,v 1.7 2002/07/11 12:35:03 takayama Exp $ */
#include "ca.h"
#include "parse.h"
#include "ox.h"
#include "ifplot.h"
#include "cursor.h"

#define MAG 1
#define PRINT_XOFFSET   100
#define PRINT_YOFFSET   100


static FILE *Fp = NULL;

static void polyLine_outputProlog(int xmin, int ymin, int xmax, int ymax, int upsidedown);
static void polyLine_outputEpilog(void);
static void polyLine_error(char *s);
#define translateX(x)  (x*MAG+PRINT_XOFFSET)
#define translateY(y)  (y*MAG+PRINT_YOFFSET)
/* #define translateY(y) ((Ysize-y)*MAG+PRINT_YOFFSET) */
#define IS_DOT    != 0
#define IS_POLYLINE  > -1
#define YES 1
#define NO  0

static int Xsize = 0;
static int Ysize = 0;

static void polyLine_outputPS_dashed_line(int x0,int y0,int x1,int y1);
static int polyLine_pline(struct canvas *can);
static int Strategy_generate_PS = 0;


static void polyLine_outputProlog(int xmin, int ymin,int xmax, int ymax, int upsidedown) {
  fprintf(Fp,"%%!PS-Adobe-1.0\n");
  fprintf(Fp,"%%%%BoundingBox: %d %d %d %d \n",
		  PRINT_XOFFSET+xmin*MAG,PRINT_YOFFSET+ymin*MAG,
		  PRINT_XOFFSET+xmax*MAG, PRINT_YOFFSET+ymax*MAG);
  fprintf(Fp,"%%%%Creator: This is generated by ifplot\n");
  fprintf(Fp,"%%%%Title: ifplot\n");
  fprintf(Fp,"%%%%EndComments: \n");
  if ( upsidedown )
	fprintf(Fp,"[1 0 0 -1 0 %d] concat \n",2*PRINT_YOFFSET+(ymin+ymax)*MAG);
  fprintf(Fp,"0.1 setlinewidth \n");
  fprintf(Fp,"2 setlinecap \n");
  fprintf(Fp,"2 setlinejoin \n");
  fprintf(Fp,"/ifplot_putpixel {  \n");
  fprintf(Fp,"    /yyy 2 1 roll def /xxx 2 1 roll def \n");
  fprintf(Fp,"    gsave newpath xxx yyy .5 0 360 arc \n");
  fprintf(Fp,"    fill grestore \n");
  fprintf(Fp,"} def \n");
  fflush(Fp);
}
static void polyLine_outputEpilog(void) {
  fprintf(Fp,"0 0 0 setrgbcolor \n");
  fprintf(Fp,"showpage \n"); fflush(Fp);
}
static void polyLine_error(char *s) {
  fprintf(stderr,"Error in smoothing: %s\n",s);
  exit(-1);
}

static void polyLine_outputPS_dashed_line(int x0,int y0,int x1,int y1) {
  extern FILE *Fp;
  fprintf(Fp," gsave [3] 0 setdash newpath \n");
  fprintf(Fp," %d %d moveto %d %d lineto stroke \n",x0,y0,x1,y1);
  fprintf(Fp," stroke grestore \n");
}

#define D 5
static int polyLine_pline(can)
struct canvas *can;
{
	double w,w1,k,e,n;
	int x0,y0,x,y,xadj,yadj;
	char buf[BUFSIZ];
	double adjust_scale();

	if ( can->noaxis )
		return;

	xadj = yadj = 0;
	if ( (can->xmin < 0) && (can->xmax > 0) ) {
		x0 = (int)((can->width-1)*(-can->xmin/(can->xmax-can->xmin)));
		polyLine_outputPS_dashed_line(translateX(x0),translateY(0),
									  translateX(x0),translateY(can->height));
	} else if ( can->xmin >= 0 )
		x0 = 0;
	else
		x0 = can->width-1-D;
	if ( (can->ymin < 0) && (can->ymax > 0) ) {
		y0 = (int)((can->height-1)*(can->ymax/(can->ymax-can->ymin)));
		polyLine_outputPS_dashed_line(translateX(0),translateY(y0),
									  translateX(can->width),translateY(y0));
	} else if ( can->ymin >= 0 )
		y0 = can->height-1;
	else
		y0 = D;
	/* BUG:  not written yet a code for PS.
	w = can->xmax-can->xmin; 
	w1 = w * DEFAULTWIDTH/can->width;
	e = adjust_scale(EXP10(floor(log10(w1))),w1);
	for ( n = ceil(can->xmin/e); n*e<= can->xmax; n++ ) {
		x = (int)can->width*(n*e-can->xmin)/w;
		DRAWLINE(display,d,drawGC,x,y0,x,y0-D);
		sprintf(buf,"%g",n*e);
		DRAWSTRING(display,d,scaleGC,x+2,y0,buf,strlen(buf));
	}
	w = can->ymax-can->ymin;
	w1 = w * DEFAULTHEIGHT/can->height;
	e = adjust_scale(EXP10(floor(log10(w1))),w1);
	for ( n = ceil(can->ymin/e); n*e<= can->ymax; n++ ) {
		y = (int)can->height*(1-(n*e-can->ymin)/w);
		DRAWLINE(display,d,drawGC,x0,y,x0+D,y);
		sprintf(buf,"%g",n*e);
		if ( can->xmax <= 0 )
			xadj = TEXTWIDTH(sffs,buf,strlen(buf));
		DRAWSTRING(display,d,scaleGC,x0-xadj,y,buf,strlen(buf));
	}
	*/
}

generatePS_from_image(FILE *fp,XImage *image,int xsize, int ysize,
					  int color[],int colorSize,
					  struct canvas *can,struct xcolorForPS *tableOfxcolorForPS,
					  int upsidedown) {
  struct polyLine **pl;
  int plSize = 0;
  int *prev;
  int *curr;
  int i,x,y,c;
  extern int Strategy_generate_PS;
  Xsize = xsize;
  Ysize = ysize;
  Fp = fp;
  polyLine_outputProlog(0,0,Xsize,Ysize,upsidedown);
  switch(Strategy_generate_PS) {
  default:
    fprintf(Fp,"%% debug info : colorSize=%d\n",colorSize);
    for (c=0; c<colorSize; c++) {
      /* Set color by looking at tableOfxcolorForPS.
      */
      fprintf(Fp,"%f %f %f setrgbcolor \n",(tableOfxcolorForPS[c]).r,(tableOfxcolorForPS[c]).g,(tableOfxcolorForPS[c]).b);
      for (x=0; x<Xsize; x++) {
        for (y=0; y<Ysize; y++) {
          if ((tableOfxcolorForPS[c]).print &&
              XGetPixel(image,x,y) == (tableOfxcolorForPS[c]).pixel){
            fprintf(Fp," %d %d ", translateX(x),translateY(y) );
            fprintf(Fp," ifplot_putpixel\n");
          }
        }
      }
    }
    break;
  }
  /* XXX : reset the color to black */
  fprintf(Fp,"0 0 0 setrgbcolor \n");
  polyLine_pline(can);
  polyLine_outputEpilog();
}




